## 拆分參數
### 1. 用匿名函式
用匿名函式去讀參數，結果會被自動收集到陣列裡

```ps1
$Arguments = @(& {return $args} $env:2)
```

但該方法有一些小問題要處理
1. 被集中到一個變數裡導致被當作一個字串傳遞 -> 用iex解套
2. 由iex導致的參數中雙引號內特定符號(錢號,反引號)被解釋 -> 把雙引號轉成單引號
3. 由於雙引號轉成單引號導致參數中...再寫下去沒完沒了就這些事自己想辦法吧XD

```ps1
$ArgumentsString = '-i input.mkv frame-%d.png -test "123 $abc"'
$Arguments = @("&{return(`$args)}$($ArgumentsString-replace([char]34,[char]39))"|Invoke-Expression)
$Arguments
```

<br>

### 2. PowerShell 內建獲取函式的方法
另一個方法是偷 PowerShell 內建獲取函式的方法，直接轉線程的物件出來用  

```ps1
$ScriptBlock = {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0, ParameterSetName = "", Mandatory)]
        [string] $Path,
        [Parameter(ParameterSetName = "")]
        [string] $Table,
        [switch] $Force
    ) $PSBoundParameters
}; $Arguments = '"C:\List 1.csv" -Table CHG.CHG.CHG_M01 -Force'
Invoke-Expression "&{$ScriptBlock} $Arguments"

```

結果

```ps1
Key   Value
---   -----
Table CHG.CHG.CHG_M01
Force True
Path  C:\List 1.csv
```

<br>

### 3. 使用 iex 解析
最優解，既然是單一參數就從頭到尾都用iex不參與實際操作就可以避開這問題了 (版本5需要反轉譯，版本7不需要)  

```ps1
$ArgumentsString = '-X POST https://httpbin.org/post -H "Content-Type: application/json" -d "{""key"": ""frame-`%d.png""}"'
if( $PSVersionTable.PSVersion.Major -le 5 ){ $ArgumentsString = $ArgumentsString -replace'([$`"''(){}[\];#&|])','`$1' }
"curl.exe $ArgumentsString" |iex

```

<br>

### 4. 使用 CMD 解析
2024-09-16 追加這個應該是最終答案了  
理由是對於使用者來說他們在這個環境下會預期應該是走 CMD 規則  
雖然這會導致 PowerShell 的解析全部失效，但這是正確的  

```ps1
$argslist = @(cmd.exe /c "for %i in ($env:1) do @echo %~i")
```
