PowerShell 單行混合代碼
===

這個版本僅能在被命名成 .cmd 時運行，主要是特化成直接呼叫ps的代碼

```ps1
@powershell "iex('#'+[io.file]::ReadAllText('%~f0'))"& exit /b
Write-Host "by PSVersion::" $PSVersionTable.PSVersion

```

最簡單的方式是像上面這樣直接呼叫，增加小老鼠以避免命令被印出  

<br><br>

## 單行混合代碼完整板

```ps1
@(set +=^)#)& setlocal enabledelayedexpansion& set "0=%~f0"& set "1=%*"& powershell -nop "iex('&{#'+[io.file]::ReadAllText($env:0)+'}'+[char]32+$env:1.replace('`','``'))-ea(1)"& exit /b !errorlevel!
[CmdletBinding()]
param (
    [Parameter(Position=0)]
    [string]$Argument1,
    [string]$Argument2,
    [switch]$ShowInfo
)
Write-Host "by PSVersion::" $PSVersionTable.PSVersion -ForegroundColor DarkGray
Write-Host "Caller   : $env:0 $env:1"
Write-Host "Argument1: $Argument1"
Write-Host "Argument2: $Argument2"
Write-Host "ShowInfo : $ShowInfo"
Exit -1

```

> [char]32 其實就是空格是為了解決第一參數使用點開頭不要解析點號  
> -replace'`','``' 是為了解決iex多消除一層反引號的問題  

<br>

測試

```ps1
.\sample\hiberid1.cmd .\AA -ShowInfo -Argument2 "``(B) B"; Write-Host "LASTEXITCODE = $LASTEXITCODE" -BackgroundColor DarkGreen
```

結果

```ps1
by PSVersion:: 5.1.22621.4249
Caller   : hiberid1.cmd .\AA -ShowInfo -Argument2 "`(B) B"
Argument1: .\AA
Argument2: `(B) B
ShowInfo : True
LASTEXITCODE = -1
```


<br><br>

## 其他

有個限制是如果寫成高級函式(以 `[CmdletBinding()]` 開頭)就無法作為ps1命名使用了  
這是因為高級函式規定 `[CmdletBinding()]` 前不能有任何非註解代碼  
